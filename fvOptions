FoamFile
{
  version 2.0; format ascii; class dictionary; object fvOptions;
}

piStarForcing
{
  type codedSource;
  active true;
  selectionMode all;
  fields (U);

  codeInclude
  #{
    #include "fvCFD.H"
  #};

  codeOptions
  #{
    -std=c++17
  #};

  codeAddSup
  #{
    const volScalarField& rho = mesh().lookupObject<volScalarField>("rho");
    volVectorField& U        = const_cast<volVectorField&>(mesh().lookupObject<volVectorField>("U"));

    const scalar A   = 0.20;
    const scalar omg = 2.0;
    const scalar t   = this->db().time().value();

    scalarField x = mesh().C().component(vector::X());
    scalarField y = mesh().C().component(vector::Y());
    vectorField FpiField(x.size(), vector::zero);
    forAll(FpiField, i)
    {
      scalar Sx = sin(x[i])*cos(y[i]);
      scalar Sy = -cos(x[i])*sin(y[i]);
      FpiField[i].x() = Sx; FpiField[i].y() = Sy;
    }

    volVectorField Fpi
    (
      IOobject("Fpi", U.time().timeName(), U.db(), IOobject::NO_READ, IOobject::NO_WRITE),
      mesh(), dimensionedVector("zero", U.dimensions(), vector::zero)
    );
    Fpi.primitiveFieldRef() = FpiField;

    volVectorField force = A * sin(omg*t) * Fpi;
    this->Su(U) += rho * force;
  #};
}

expClamp
{
  type codedSource;
  active true;
  selectionMode all;
  fields (U);

  codeAddSup
  #{
    const volScalarField& rho = mesh().lookupObject<volScalarField>("rho");
    volVectorField& U        = const_cast<volVectorField&>(mesh().lookupObject<volVectorField>("U"));

    const scalar lambda = 0.35;
    const scalar alpha  = 0.20;
    const scalar t      = this->db().time().value();
    const scalar Le     = lambda*exp(-alpha*t);

    this->Su(U) -= rho * (Le) * U;
  #};
}

gammaDiss
{
  type codedSource;
  active true;
  selectionMode all;
  fields (U);

  codeInclude
  #{
    #include "fvCFD.H"
  #};

  codeAddSup
  #{
    const fvMesh& m = this->mesh();
    const volScalarField& rho = m.lookupObject<volScalarField>("rho");
    volVectorField& U        = const_cast<volVectorField&>(m.lookupObject<volVectorField>("U"));

    volVectorField vort  = Foam::curl(U);
    volScalarField omega2 = magSqr(vort);

    scalar omMin = gMin(omega2).value();
    scalar omMax = gMax(omega2).value() + SMALL;
    volScalarField sensor = (omega2 - omMin)/(omMax - omMin);

    volScalarField divU = fvc::div(U);
    volScalarField shockMask = pos(divU + 1e-3);

    const scalar t = this->db().time().value();
    const scalar period = (2.0*constant::mathematical::pi)/2.0;
    scalar phase = fmod(t, period)/period;
    scalar zGate = (phase > 0.60 && phase < 0.90) ? 1.0 : 0.0;

    const scalar gamma0 = 0.70;
    volScalarField coeff = gamma0 * sensor * shockMask * zGate;

    this->Su(U) -= rho * coeff * U;
  #};
}
